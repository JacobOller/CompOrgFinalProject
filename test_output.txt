============================= test session starts =============================
platform win32 -- Python 3.12.4, pytest-9.0.1, pluggy-1.6.0
rootdir: C:\Users\jacob\OneDrive\School Cloud\Semester 3\Computer Organization\Final Project
collected 68 items

cpu_test.py .F...FFFF.CRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
F...........F........................FF [ 88%]
FFFFCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FCRASH DEBUG: The bad opcode is number: 0
FF                                                                 [100%]

================================== FAILURES ===================================
____________________ test_load_program_after_instantiation ____________________

    def test_load_program_after_instantiation():
        """
        Ensure we can load a program (once) after instantiation
        """
        alu = Alu()
        d_mem = DataMemory()
        i_mem = InstructionMemory()
        regs = RegisterFile()
        c = Cpu(alu=alu, d_mem=d_mem, i_mem=i_mem, regs=regs)
        prog = [0x0202, 0x0404, 0x5650, 0x58C8, 0x4B0A, 0xF000]
        c.load_program(prog)
        for i in prog:
            c.tick()
>           assert int(c.decoded.raw_hex, 16) == i
E           AssertionError: assert 22096 == 1028
E            +  where 22096 = int('0x5650', 16)
E            +    where '0x5650' = Instruction(ADD (opcode=5): rd=0x3, ra=0x1, rb=0x2, zero=0, raw_hex=0x5650, raw_bin=0b0101011001010000).raw_hex
E            +      where Instruction(ADD (opcode=5): rd=0x3, ra=0x1, rb=0x2, zero=0, raw_hex=0x5650, raw_bin=0b0101011001010000) = <cpu.Cpu object at 0x00000191441031A0>.decoded

cpu_test.py:49: AssertionError
___________________________ test_bne_forward_label ____________________________

    def test_bne_forward_label():
        """
        Ensure BNE branches correctly on forward label
        """
        prog = assemble(
            [
                "BNE SKIP",  # should branch if Z==0
                "LOADI R0, #99",  # this should be skipped
                "SKIP:",
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c._alu._flags = 0b0000  # simulate ALU flags from prior op
>       c.tick()  # execute branch
        ^^^^^^^^

cpu_test.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(BNE (opcode=11): ra=0x0, imm=0x00, zero=0x1, raw_hex=0xB001, raw_bin=0b1011000000000001)
word = 45057

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on BNE!
Raw word (hex): B001
Raw word (bin): 1011000000000001
Problem with decoding? Or assembler bug?
___________________________ test_bne_backward_label ___________________________

    def test_bne_backward_label():
        """
        Ensure BNE branches correctly on backward label
        """
        prog = assemble(
            [
                "LOADI R1 #2",
                "LOADI R2 #1",
                "LOOP:",
                "SUB R1, R2, R1",
                "BNE LOOP",
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
        c.tick()  # SUB
        old_flags = c._alu._flags  # OK to access in tests
        c.tick()
>       assert c.pc == 2  # PC jumped back to LOOP
        ^^^^^^^^^^^^^^^^
E       assert 5 == 2
E        +  where 5 = <cpu.Cpu object at 0x0000019144121C70>.pc

cpu_test.py:136: AssertionError
___________________________ test_beq_forward_label ____________________________

    def test_beq_forward_label():
        """
        Ensure BEQ branches correctly on forward label
        """
        prog = assemble(
            [
                "BEQ SKIP",  # should branch if Z==1
                "LOADI R0, #99",  # this should be skipped
                "SKIP:",
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c._alu._flags = 0b0000 | Z_FLAG  # simulate ALU flags from prior op
        old_flags = c._alu._flags  # OK to access in tests
>       c.tick()  # execute branch
        ^^^^^^^^

cpu_test.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(BEQ (opcode=10): ra=0x0, imm=0x00, zero=0x1, raw_hex=0xA001, raw_bin=0b1010000000000001)
word = 40961

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on BEQ!
Raw word (hex): A001
Raw word (bin): 1010000000000001
Problem with decoding? Or assembler bug?
___________________________ test_beq_backward_label ___________________________

    def test_beq_backward_label():
        """
        Ensure BEQ branches correctly on backward label
        """
        prog = assemble(
            [
                "LOADI R1 #3",
                "LOADI R2 #3",
                "LOOP:",
                "SUB R1, R1, R2",
                "BEQ LOOP",
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
        c.tick()  # SUB
        # Now step BEQ and confirm it branches correctly
        old_flags = c._alu._flags  # OK to access in tests
        c.tick()
>       assert c.decoded.mnem == "BEQ"
E       AssertionError: assert 'HALT' == 'BEQ'
E         
E         - BEQ
E         + HALT

cpu_test.py:185: AssertionError
___________________________ test_lui[prog0-1-32768] ___________________________

prog = [512, 4864], reg = 1, expected = 32768

    @pytest.mark.parametrize(
        "prog,reg,expected",
        [
            (["LOADI R1, #0", "LUI R1, 128"], 1, 0x8000),
            (["LOADI R1, #0xAB", "LUI R1, #0xCD"], 1, 0xCDAB),
        ],
    )
    def test_lui(prog, reg, expected):
        """
        Ensure LUI writes correctly to upper byte of specified register, and
        combined result (upper and lower bytes) is correct.
        """
        prog = assemble(prog)
        c = make_cpu(prog)
        c.tick()  # LOADI
>       c.tick()  # LUI
        ^^^^^^^^

cpu_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144103f80>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
___________________________ test_lui[prog1-1-52651] ___________________________

prog = [854, 5018], reg = 1, expected = 52651

    @pytest.mark.parametrize(
        "prog,reg,expected",
        [
            (["LOADI R1, #0", "LUI R1, 128"], 1, 0x8000),
            (["LOADI R1, #0xAB", "LUI R1, #0xCD"], 1, 0xCDAB),
        ],
    )
    def test_lui(prog, reg, expected):
        """
        Ensure LUI writes correctly to upper byte of specified register, and
        combined result (upper and lower bytes) is correct.
        """
        prog = assemble(prog)
        c = make_cpu(prog)
        c.tick()  # LOADI
>       c.tick()  # LUI
        ^^^^^^^^

cpu_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144101d30>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
__________________________________ test_sub ___________________________________

    def test_sub():
        """
        Ensure SUB writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #3", "LOADI R2, #2", "SUB R3, R1, R2"])
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # SUB
        ^^^^^^^^

cpu_test.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144120830>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
__________________________________ test_add ___________________________________

    def test_add():
        """
        Ensure ADD writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #3", "LOADI R2, #2", "ADD R3, R1, R2"])
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # ADD
        ^^^^^^^^

cpu_test.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144122ae0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
__________________________________ test_addi __________________________________

    def test_addi():
        """
        Ensure ADDI writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #3", "ADDI R5, R1, #4"])
        c = make_cpu(prog)
        c.tick()  # LOADI
>       c.tick()  # ADDI
        ^^^^^^^^

cpu_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x191441039e0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
__________________________________ test_and ___________________________________

    def test_and():
        """
        Ensure AND writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #5", "LOADI R2, #10", "AND R3, R1, R2"])
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # AND
        ^^^^^^^^

cpu_test.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144121ac0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
___________________________________ test_or ___________________________________

    def test_or():
        """
        Ensure OR writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #5", "LOADI R2, #10", "OR R3, R1, R2"])
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # OR
        ^^^^^^^^

cpu_test.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144121fa0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
_______________________________ test_shift_left _______________________________

    def test_shift_left():
        """
        Ensure SHFT (left) writes correct result to specified register
        """
        prog = assemble(["LOADI R1, #5", "LOADI R2, #4", "SHFT R3, R1, R2"])
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # SHFT
        ^^^^^^^^

cpu_test.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144126630>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
______________________________ test_shift_right _______________________________

    def test_shift_right():
        """
        Ensure SHFT (right) writes correct result to specified register
        """
        prog = assemble(
            ["LOADI R1, #128", "LOADI R2, #5", "LUI R2, #128", "SHFT R3, R1, R2"]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
        c.tick()  # LUI
>       c.tick()  # SHFT
        ^^^^^^^^

cpu_test.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144122db0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
___________________________ test_load_uninitialized ___________________________

    def test_load_uninitialized():
        """
        Ensure load from uninitialized address loads zero (default)
        """
        prog = assemble(["LOADI R1, #0x0", "LOAD R2, [R1 + #0]"])
        c = make_cpu(prog)
        c.tick()  # LOADI
>       c.tick()  # LOAD
        ^^^^^^^^

cpu_test.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x191441032c0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
_______________________________ test_load_store _______________________________

    def test_load_store():
        """
        Ensure load / store round-trip
        """
        prog = assemble(
            [
                "LOADI R1, #0xAB     ; data",
                "LOADI R2, #0x0      ; base addr",
                "STORE R1, [R2 + #0]  ; store data in R1 to [R2 + #0]",
                "LOAD R3, [R2 + #0]   ; load from [R2 + #0] into R3",
            ]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI (data)
        assert c._regs.execute(ra=1) == (0xAB, None)  # OK to access in tests
        c.tick()  # LOADI (target adddress)
        assert c._regs.execute(ra=2) == (0x0, None)  # OK to access in tests
>       c.tick()  # STORE
        ^^^^^^^^

cpu_test.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x191441271d0>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
____________________________ test_opcode_smoke[0] _____________________________

instr = 0

    @pytest.mark.parametrize(
        "instr",
        [
            0x0000,  # LOADI
            0x1120,  # LUI
            0x24B5,  # LOAD
            0x3A16,  # STORE
            0x4B3E,  # ADDI
            0x5640,  # ADD
            0x68B8,  # SUB
            0x7CC0,  # AND
            0x8098,  # OR
            0x9550,  # SHFT,
            0xAF44,  # BEQ
            0xB080,  # BNE
            0xCCF6,  # B
            0xD380,  # CALL
            0xE000,  # RET
            0xF000,  # HALT
        ],
    )
    def test_opcode_smoke(instr):
        """
        Test representatives of each opcode
        """
        prog = [instr]
        c = make_cpu(prog)
>       c.tick()  # [instr]
        ^^^^^^^^

cpu_test.py:371: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144125850>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
__________________________ test_opcode_smoke[52470] ___________________________

instr = 52470

    @pytest.mark.parametrize(
        "instr",
        [
            0x0000,  # LOADI
            0x1120,  # LUI
            0x24B5,  # LOAD
            0x3A16,  # STORE
            0x4B3E,  # ADDI
            0x5640,  # ADD
            0x68B8,  # SUB
            0x7CC0,  # AND
            0x8098,  # OR
            0x9550,  # SHFT,
            0xAF44,  # BEQ
            0xB080,  # BNE
            0xCCF6,  # B
            0xD380,  # CALL
            0xE000,  # RET
            0xF000,  # HALT
        ],
    )
    def test_opcode_smoke(instr):
        """
        Test representatives of each opcode
        """
        prog = [instr]
        c = make_cpu(prog)
>       c.tick()  # [instr]
        ^^^^^^^^

cpu_test.py:371: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(B (opcode=12): imm=0xCF, zero=0x6, raw_hex=0xCCF6, raw_bin=0b1100110011110110)
word = 52470

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on B!
Raw word (hex): CCF6
Raw word (bin): 1100110011110110
Problem with decoding? Or assembler bug?
___________________________ test_branch_zero_offset ___________________________

    def test_branch_zero_offset():
        prog = assemble(
            [
                "B HERE",  # offset 0
                "LOADI R1, #99",
                "HERE:",
                "HALT",
            ]
        )
        c = make_cpu(prog)
>       c.tick()  # B HERE
        ^^^^^^^^

cpu_test.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(B (opcode=12): imm=0x00, zero=0x1, raw_hex=0xC001, raw_bin=0b1100000000000001)
word = 49153

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on B!
Raw word (hex): C001
Raw word (bin): 1100000000000001
Problem with decoding? Or assembler bug?
________________________ test_branch_forward_plus_one _________________________

    def test_branch_forward_plus_one():
        """
        Ensure correct branch forward by one
        """
        prog = assemble(
            [
                "B SKIP",  # offset + 1
                "LOADI R1, #99",
                "SKIP:",
                "HALT",
            ]
        )
        c = make_cpu(prog)
>       c.tick()

cpu_test.py:532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(B (opcode=12): imm=0x00, zero=0x1, raw_hex=0xC001, raw_bin=0b1100000000000001)
word = 49153

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on B!
Raw word (hex): C001
Raw word (bin): 1100000000000001
Problem with decoding? Or assembler bug?
_______________________ test_branch_backward_minus_one ________________________

    def test_branch_backward_minus_one():
        """
        Ensure correct branch backward by one
        """
        prog = assemble(
            [
                "LOADI R1, #0",
                "LOOP:",
                "B LOOP",  # offset = -1
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # B LOOP
>       assert c.pc == 1
E       assert 3 == 1
E        +  where 3 = <cpu.Cpu object at 0x0000019144179E20>.pc

cpu_test.py:551: AssertionError
___________________________ test_branch_max_forward ___________________________

    def test_branch_max_forward():
        """
        Our ISA limits the size of jumps.
        Jump from instruction 0 to instruction 32 (max).
        """
        asm = ["B FAR"]
        asm += ["LOADI R0, #0"] * 31  # fill
        asm += ["FAR:", "HALT"]
        prog = assemble(asm)
    
        c = make_cpu(prog)
>       c.tick()  # B FAR
        ^^^^^^^^

cpu_test.py:565: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(B (opcode=12): imm=0x01, zero=0xF, raw_hex=0xC01F, raw_bin=0b1100000000011111)
word = 49183

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on B!
Raw word (hex): C01F
Raw word (bin): 1100000000011111
Problem with decoding? Or assembler bug?
__________________________ test_branch_max_backward ___________________________

    def test_branch_max_backward():
        """
        Our ISA limits the size of jumps.
        Jump from instruction 0 to instruction -31 (max).
        """
        asm = (
            [
                "ADDI R0, R0, #0",  # because we don't have a NOP
                "LOOP:",
            ]
            + ["ADDI R0, R0, #0"] * 30
            + [
                "B LOOP",  # With PC = 32, offset must be -31
                "HALT",
            ]
        )
    
        prog = assemble(asm)
        c = make_cpu(prog)
        for _ in range(32):
            c.tick()
        c.tick()
    
>       assert c.pc == 2  # backward target
        ^^^^^^^^^^^^^^^^
E       assert 33 == 2
E        +  where 33 = <cpu.Cpu object at 0x00000191441278F0>.pc

cpu_test.py:595: AssertionError
____________________________ test_branch_self_loop ____________________________

    def test_branch_self_loop():
        """
        Ensure infinite loop is infinite!
        """
        prog = assemble(
            [
                "LOOP:",
                "B LOOP",
            ]
        )
        c = make_cpu(prog)
>       c.tick()

cpu_test.py:609: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:71: in tick
    self._decode()
cpu.py:224: in _decode
    self._decoded = Instruction(raw=self._ir)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
<string>:12: in __init__
    ???
instruction_set.py:278: in __post_init__
    self._decode_from_word(self.raw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Instruction(B (opcode=12): imm=0x0F, zero=0xF, raw_hex=0xC0FF, raw_bin=0b1100000011111111)
word = 49407

    def _decode_from_word(self, word):
        """
        Self-decode instruction from 16-bit word.
        """
        self.opcode = (word >> 12) & 0xF
        self.mnem = OPCODE_MAP.get(self.opcode, "???")
        fmt = self.format
        if fmt == 'R':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.rb = (word >> 3) & 0x7
            self.zero = word & 0x7            # 4-bit zero padding
        elif self.mnem in ('LOADI', 'LUI'):
            self.rd = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        elif self.mnem == 'ADDI':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.imm = word & 0x3F
            self.zero = 0                     # no zero padding
        elif fmt == 'M':
            self.rd = (word >> 9) & 0x7
            self.ra = (word >> 6) & 0x7
            self.addr = word & 0x3F           # 63 (6 bits)
            self.zero = 0                     # no zero padding
        elif self.mnem == 'CALL':             # added 2025-10-31
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif self.mnem in ('RET', 'HALT'):    # added 2025-10-31
            self.zero = word & 0xFFF          # 12-bit zero padding
        elif self.mnem == 'B':                # added 2025-11-01
            self.imm = (word >> 4) & 0xFF
            self.zero = word & 0xF            # 4-bit zero padding
        elif fmt == 'B':                      # B, BEQ and BNE
            self.ra = (word >> 9) & 0x7
            self.imm = (word >> 1) & 0xFF     # fixed 2025-10-31
            self.zero = word & 1              # 1-bit zero padding
        else:
            raise ValueError(f"Unhandled instruction {self.mnem}")
        self.raw = word
        try:                                  # added 2025-10-31
>           assert self.zero == 0
                   ^^^^^^^^^^^^^^
E           AssertionError

instruction_set.py:336: AssertionError
---------------------------- Captured stdout call -----------------------------
BAD zero padding on B!
Raw word (hex): C0FF
Raw word (bin): 1100000011111111
Problem with decoding? Or assembler bug?
_______________________________ test_sub_logic ________________________________

    def test_sub_logic():
        prog = assemble(
            [
                "LOADI R5, #32",  # a
                "LOADI R6, #16",  # b
                "SUB R7, R5, R6",  # a - b
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c.tick()  # LOADI
        c.tick()  # LOADI
>       c.tick()  # SUB
        ^^^^^^^^

cpu_test.py:628: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144121520>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
_________________________ test_lui_expected_behavior __________________________

    def test_lui_expected_behavior():
        prog = assemble(["LOADI R3, #0", "LUI R3, #0x80"])
        c = make_cpu(prog)
        c.tick()  # LOADI
>       c.tick()  # LUI
        ^^^^^^^^

cpu_test.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144122d80>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
________________________ test_subtract_mutation_order _________________________

    def test_subtract_mutation_order():
        prog = assemble(
            [
                "LOADI R5, #32",  # a = 32
                "LOADI R6, #16",  # b = 16
                "SUB R6, R6, R5",  # b = b - a => should be -16 (0xFFF0)
                "HALT",
            ]
        )
        c = make_cpu(prog)
        c.tick()
        c.tick()
>       c.tick()

cpu_test.py:652: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
cpu.py:214: in tick
    "Unknown mnemonic: " + str(self._decoded) + "\n" + str(self._ir)
                           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[ValueError('Instruction format unknown') raised in repr()] Instruction object at 0x19144100260>

    def __repr__(self):
        """
        Revised 2025-11-01 to include raw bytes and conditional
        formatting by opcode, and to format fields as hex.
        """
        s = f"Instruction({self.mnem} (opcode={self.opcode}): "
        fmt = self.format
        if fmt is None:
            # --- DEBUGGING LINES START ---
            print(f"CRASH DEBUG: The bad opcode is number: {self.opcode}")
            # --- DEBUGGING LINES END ---
>           raise ValueError("Instruction format unknown")
E           ValueError: Instruction format unknown

instruction_set.py:369: ValueError
---------------------------- Captured stdout call -----------------------------
CRASH DEBUG: The bad opcode is number: 0
________________________ test_and_resets_negative_flag ________________________

    def test_and_resets_negative_flag():
        prog = assemble(
            [
                "LOADI R1, #0",
                "LOADI R2, #0",
                "SUB R3, R1, R2",  # zero result, flags: Z=1, N=0
                "LOADI R1, #1",
                "SUB R3, R2, R1",  # negative result, flags: N=1, Z=0
                "AND R4, R2, R2",  # 0 & 0 \u2192 should set Z=1, N=0
                "HALT",
            ]
        )
        c = make_cpu(prog)
        assert not c._alu.zero
        assert not c._alu.negative
        assert not c._alu.carry
        assert not c._alu.overflow
        c.tick()
        c.tick()
        c.tick()
        assert c._alu.zero
        assert not c._alu.negative
        assert c._alu.carry
        assert not c._alu.overflow
        c.tick()
        c.tick()
>       assert not c._alu.zero
E       assert not True
E        +  where True = <alu.Alu object at 0x0000019144122150>.zero
E        +    where <alu.Alu object at 0x0000019144122150> = <cpu.Cpu object at 0x0000019144122510>._alu

cpu_test.py:682: AssertionError
=========================== short test summary info ===========================
FAILED cpu_test.py::test_load_program_after_instantiation - AssertionError: a...
FAILED cpu_test.py::test_bne_forward_label - AssertionError
FAILED cpu_test.py::test_bne_backward_label - assert 5 == 2
FAILED cpu_test.py::test_beq_forward_label - AssertionError
FAILED cpu_test.py::test_beq_backward_label - AssertionError: assert 'HALT' =...
FAILED cpu_test.py::test_lui[prog0-1-32768] - ValueError: Instruction format ...
FAILED cpu_test.py::test_lui[prog1-1-52651] - ValueError: Instruction format ...
FAILED cpu_test.py::test_sub - ValueError: Instruction format unknown
FAILED cpu_test.py::test_add - ValueError: Instruction format unknown
FAILED cpu_test.py::test_addi - ValueError: Instruction format unknown
FAILED cpu_test.py::test_and - ValueError: Instruction format unknown
FAILED cpu_test.py::test_or - ValueError: Instruction format unknown
FAILED cpu_test.py::test_shift_left - ValueError: Instruction format unknown
FAILED cpu_test.py::test_shift_right - ValueError: Instruction format unknown
FAILED cpu_test.py::test_load_uninitialized - ValueError: Instruction format ...
FAILED cpu_test.py::test_load_store - ValueError: Instruction format unknown
FAILED cpu_test.py::test_opcode_smoke[0] - ValueError: Instruction format unk...
FAILED cpu_test.py::test_opcode_smoke[52470] - AssertionError
FAILED cpu_test.py::test_branch_zero_offset - AssertionError
FAILED cpu_test.py::test_branch_forward_plus_one - AssertionError
FAILED cpu_test.py::test_branch_backward_minus_one - assert 3 == 1
FAILED cpu_test.py::test_branch_max_forward - AssertionError
FAILED cpu_test.py::test_branch_max_backward - assert 33 == 2
FAILED cpu_test.py::test_branch_self_loop - AssertionError
FAILED cpu_test.py::test_sub_logic - ValueError: Instruction format unknown
FAILED cpu_test.py::test_lui_expected_behavior - ValueError: Instruction form...
FAILED cpu_test.py::test_subtract_mutation_order - ValueError: Instruction fo...
FAILED cpu_test.py::test_and_resets_negative_flag - assert not True
======================== 28 failed, 40 passed in 0.68s ========================
